package burp;

import java.io.IOException;
import java.net.URL;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static burp.BurpExtender.mStdErr;

/**
 * Class to find interesting stuff in JavaScript & JSON files
 */

public class InterestingStuffFinder implements Runnable {
    private static final IBurpExtenderCallbacks callbacks = BurpExtender.getCallbacks();
    private static final IExtensionHelpers helpers = callbacks.getHelpers();
    private final IHttpRequestResponse[] baseRequestResponseArray;
    private final long timeStamp;
    private static final String WHITE_SPACES = "(\\s*)";
    public static final String REGEX_QUOTES = "['\"`]";

    private static final Pattern CLOUD_URLS_REGEX = Pattern.compile("([\\w]+[.]){1,10}" + // get up to 10 subdomain levels
                    "(s3.amazonaws.com|rds.amazonaws.com|cache.amazonaws.com|" + // AWS
                    "blob.core.windows.net|onedrive.live.com|1drv.com|" + // Azure
                    "storage.googleapis.com|storage.cloud.google.com|storage-download.googleapis.com|content-storage-upload.googleapis.com|content-storage-download.googleapis.com|" + // Google
                    "cloudfront.net|" +
                    "digitaloceanspaces.com|" +
                    "oraclecloud.com|" +
                    "aliyuncs.com|" + // Ali baba
                    "firebaseio.com|" + // Firebase
                    "rackcdn.com|" +
                    "objects.cdn.dream.io|objects-us-west-1.dream.io)",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    // Inspired by: https://github.com/nsonaniya2010/SubDomainizer/blob/master/SubDomainizer.py
    private static final Pattern SECRETS_REGEX = Pattern.compile(("['\"`]?(\\w*)" + // Starts with a quote then a word / white spaces
                    WHITE_SPACES +
                    "(secret|token|password|passwd|authorization|bearer|aws_access_key_id|aws_secret_access_key|irc_pass|SLACK_BOT_TOKEN|id_dsa" +
                    "secret[_-]?(key|token|secret)|" +
                    "api[_-]?(key|token|secret)|" +
                    "access[_-]?(key|token|secret)|" +
                    "auth[_-]?(key|token|secret)|" +
                    "session[_-]?(key|token|secret)|" +
                    "consumer[_-]?(key|token|secret)|" +
                    "private[_-]?(key|token|secret)|" +
                    "client[_-]?(id|token|key)|" +
                    "ssh[_-]?key|" +
                    "encrypt[_-]?(secret|key)|" +
                    "decrypt[_-]?(secret|key)|" +
                    "github[_-]?(key|token|secret)|" +
                    "slack[_-]?token)" +
                    "(\\w*)" + // in case there are any characters / white spaces
                    WHITE_SPACES +
                    "['\"`]?" + // closing quote for variable name
                    WHITE_SPACES +// white spaces
                    "[:=]+[:=>]?" +// assignments operation
                    WHITE_SPACES +
                    REGEX_QUOTES + // opening quote for secret
                    WHITE_SPACES +
                    "([\\w\\-/~!@#$%^&*+]+)" + // Assuming secrets will be alphanumeric with some special characters
                    WHITE_SPACES +
                    REGEX_QUOTES // closing quote for secrets
            ),
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    private static final Pattern b64SourceMapRegex = Pattern.compile("sourceMappingURL=data(.*)json(.*)base64,((?:[a-z0-9+/]{4})*(?:[a-z0-9+/]{2}==|[a-z0-9+/]{3}=)?)(\\\\n)?",
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);

    private static final Pattern EXTRACT_DEPENDENCIES_REGEX = Pattern.compile((
                    "dependencies" + // we don't care about prefix. Once we find this, just check what comes next
                            "([a-z-_0-9])*" + // some suffix may be (e.g.: dependenciesDev1_2-3)
                            REGEX_QUOTES + // closing quote
                            ":" + // mandatory colon
                            "\\{" + // mandatory opening curly brackets
                            "(.*?)" +   // our dependencies list -> matcher.group(2)
                            "}"     // mandatory closing curly brackets
            ),
            Pattern.CASE_INSENSITIVE | Pattern.MULTILINE);


    private static final String SCAN_ISSUE_HEADER = "This issue was generated by \"" + BurpExtender.EXTENSION_NAME + "\" Burp extension.<br><br>";
    private static final String CONFIDENCE_CERTAIN = "Certain";
    private static final String CONFIDENCE_TENTATIVE = "Tentative";
    private static final String CONFIDENCE_FIRM = "Firm";
    private static final String SEVERITY_INFORMATION = "Information";
    private static final String SEVERITY_MEDIUM = "Medium";
    private static final String SEVERITY_HIGH = "High";
    private static final String HTML_LIST_OPEN = "<ul>";
    private static final String HTML_LIST_BULLET_OPEN = "<li> ";
    private static final String HTML_LIST_BULLET_CLOSED = "</li>";
    private static final String HTML_LIST_CLOSED = "</ul>";


    InterestingStuffFinder(IHttpRequestResponse[] baseRequestResponseArray, long timeStamp) {
        this.baseRequestResponseArray = baseRequestResponseArray;
        this.timeStamp = timeStamp;
    }

    public void run() {
        try {
            for (IHttpRequestResponse baseRequestResponse : baseRequestResponseArray) {
                // only process ".js" and ".json" files
                if (baseRequestResponse.getResponse() != null
                        &&
                        (
                                (helpers.analyzeRequest(baseRequestResponse).getUrl().getPath().endsWith(".js"))
                                        || (helpers.analyzeRequest(baseRequestResponse).getUrl().getPath().endsWith(".json"))
                        )
                        && BurpExtender.isLoaded()
                ) {
                    String responseString = new String(baseRequestResponse.getResponse());
                    String responseBodyString = responseString.substring(helpers.analyzeResponse(baseRequestResponse.getResponse()).getBodyOffset());
                    mainHandler(baseRequestResponse, responseBodyString, timeStamp);
                }
            }
        } catch (Exception e) {
            try {
                throw e;
            } catch (Exception ex) {
                mStdErr.println("InterestingStuffFinder run Exception");
                StackTraceElement[] traces = ex.getStackTrace();
                for (StackTraceElement trace : traces) {
                    mStdErr.println(trace);
                }
            }
        }
    }

    private void mainHandler(IHttpRequestResponse baseRequestResponse, String responseBodyString, long timeStamp) throws InterruptedException, IOException {
        findDependencyConfusion(baseRequestResponse, responseBodyString);
        handleInlineMapFiles(baseRequestResponse, responseBodyString, timeStamp);
        findSecrets(baseRequestResponse, responseBodyString);
        findSubDomains(baseRequestResponse, responseBodyString);
        findCloudURLs(baseRequestResponse, responseBodyString);
    }

    /**
     * Scan function 1 - Check all strings for potential secrets (uses Shannon Entropy to increase confidence)
     */
    private void findSecrets(IHttpRequestResponse baseRequestResponse, String responseBodyString) throws InterruptedException {

        Matcher matcherSecrets = SECRETS_REGEX.matcher(new InterruptibleCharSequence(responseBodyString));
        Runnable runnable = () -> {
            while (matcherSecrets.find() && BurpExtender.isLoaded()) {
                List<int[]> secretsMatches = Utilities.getMatches(baseRequestResponse.getResponse(), helpers.stringToBytes(matcherSecrets.group()));
                double entropy = Utilities.getShannonEntropy(matcherSecrets.group(20)); // group(2) matches our secret
                String confidence;
                String description;
                if (entropy >= 3.5) {
                    // if high entropy, confidence is "Firm"
                    confidence = CONFIDENCE_FIRM;
                    description = "The following secret has high entropy and it was found in a JavaScript file.";
                } else {
                    // if low entropy, confidence is "Tentative"
                    confidence = CONFIDENCE_TENTATIVE;
                    description = "The following secret has low entropy and it was found in a JavaScript file.";
                }
                sendNewIssue(baseRequestResponse,
                        "[JS Miner] Secrets / Credentials",
                        description,
                        matcherSecrets.group(),
                        secretsMatches,
                        SEVERITY_MEDIUM,
                        confidence
                );
            }
        };
        Utilities.regexRunnerWithTimeOut(runnable);
    }

    /**
     * Scan function 2 - Get all subdomains
     */
    private void findSubDomains(IHttpRequestResponse baseRequestResponse, String responseBodyString) throws InterruptedException {
        String domainFromReferer = Utilities.getDomainFromReferer(baseRequestResponse);
        String requestDomain = helpers.analyzeRequest(baseRequestResponse).getUrl().getHost();
        String rootDomain;
        // Try to get caller domain from Referer header (to avoid matching cdn subdomains, ..etc.)
        if (domainFromReferer != null) {
            rootDomain = domainFromReferer;
        } else {
            // If the above failed, then use the domain from the HTTP request
            rootDomain = Utilities.getRootDomain(requestDomain);
        }

        Runnable runnable = () -> {
            if (rootDomain != null) {
                // Simple SubDomains Regex
                Pattern subDomainsRegex = Pattern.compile("([a-z0-9]+[.])+" + rootDomain, Pattern.CASE_INSENSITIVE);
                Matcher matcherSubDomains = subDomainsRegex.matcher(new InterruptibleCharSequence(responseBodyString));
                while (matcherSubDomains.find() && BurpExtender.isLoaded()) {
                    if (
                            Utilities.isMatchedDomainValid(matcherSubDomains.group(), rootDomain, requestDomain)
                    ) {
                        // Get markers of found subdomains
                        List<int[]> subDomainsMatches = Utilities.getMatches(baseRequestResponse.getResponse(), matcherSubDomains.group().getBytes());
                        // report the issue
                        sendNewIssue(baseRequestResponse,
                                "[JS Miner] Subdomains",
                                "The following subdomain was found in a JavaScript file.",
                                helpers.urlDecode(matcherSubDomains.group()),
                                subDomainsMatches,
                                SEVERITY_INFORMATION,
                                CONFIDENCE_CERTAIN
                        );
                    }
                }
            }
        };
        Utilities.regexRunnerWithTimeOut(runnable);
    }


    /**
     * Scan function 3 - Get Cloud URLs
     */
    private void findCloudURLs(IHttpRequestResponse baseRequestResponse, String responseBodyString) throws InterruptedException {

        Matcher cloudURLsMatcher = CLOUD_URLS_REGEX.matcher(new InterruptibleCharSequence(responseBodyString));

        Runnable runnable = () -> {
            while (cloudURLsMatcher.find() && BurpExtender.isLoaded()) {
                // Get markers of found Cloud URL Matches
                List<int[]> cloudHostsMatches = Utilities.getMatches(baseRequestResponse.getResponse(), cloudURLsMatcher.group().getBytes());
                // report the issue
                sendNewIssue(baseRequestResponse,
                        "[JS Miner] Cloud Resources",
                        "The following  cloud URL was found in a JavaScript file.",
                        cloudURLsMatcher.group(),
                        cloudHostsMatches,
                        SEVERITY_INFORMATION,
                        CONFIDENCE_CERTAIN
                );
            }
        };
        Utilities.regexRunnerWithTimeOut(runnable);
    }

    /**
     * Scan function 4 - Parse inline JS map files
     */
    private void handleInlineMapFiles(IHttpRequestResponse baseRequestResponse, String responseBodyString, long timeStamp) {

        Path outputDirPath = Paths.get(System.getProperty("user.home"))
                .resolve(".BurpSuite")
                .resolve("JS-Miner")
                .resolve(helpers.analyzeRequest(baseRequestResponse).getUrl().getHost() + "-" + timeStamp);

        Matcher b64SourceMapperMatcher = b64SourceMapRegex.matcher(responseBodyString);

        while (b64SourceMapperMatcher.find()) {
            new SourceMapper(
                    baseRequestResponse,
                    Utilities.b64Decode(b64SourceMapperMatcher.group(3)), // Base64 Decoded map File Data
                    outputDirPath
            );
        }
    }

    /**
     * Scan function 5 - Find Dependency Confusion
     */
    private void findDependencyConfusion(IHttpRequestResponse baseRequestResponse, String responseBodyString) throws IOException {
        // Removing unwanted spaces, new lines and so on, which might mislead matching our Regex
        Matcher dependenciesListMatcher = EXTRACT_DEPENDENCIES_REGEX.matcher(responseBodyString
                .replaceAll("\\s", "")
                .replace("\t", "")
                .replace("\r", "")
                .replace("\n", ""));
        while (dependenciesListMatcher.find()) {
            String dependencyList = dependenciesListMatcher.group(2);
            String[] dependencyListArray = dependencyList.split(",");
            for (String dependency : dependencyListArray) {
                // A new npm package that holds and validates name and version for later use
                NPMPackage npmPackage = new NPMPackage(dependency);

                // package name must be valid
                if (npmPackage.isNameValid()) {
                    // Get markers of each single dependency with its version
                    List<int[]> depMatches = Utilities.getMatches(baseRequestResponse.getResponse(), dependency.getBytes());
                    verifyDependencyConfusion(baseRequestResponse, npmPackage, depMatches);
                }
            }
        }
    }


    // Verify if dependency is exploitable by querying npm js registry service
    private static void verifyDependencyConfusion(IHttpRequestResponse baseRequestResponse, NPMPackage npmPackage, List<int[]> depMatches) throws IOException {
        String findingTitle;
        String findingDetail;
        String severity;

        // 1. if package version does not comply with NPM Semantic versioning, then report it as info for manual analysis
        if (!npmPackage.isVersionValidNPM()) {
            findingTitle = "[JS Miner] Dependency (Non-NPM registry package)";
            findingDetail = "The following non-NPM dependency was found in a JavaScript file. The version might contain a public repository URL, a private repository URL or a file path. Manual review is advised.";
            severity = SEVERITY_INFORMATION;
        }
        // 2. if package name starts with "@", then it's a scoped package.
        else if (npmPackage.getName().startsWith("@")) {

            String organizationName = npmPackage.getOrgNameFromScopedDependency();

            URL url = new URL("https://www.npmjs.com/org/" + organizationName);
            IHttpRequestResponse httpRequestResponse = callbacks.makeHttpRequest(Utilities.url2HttpService(url), helpers.buildHttpRequest(url));

            // 2.1 scoped package with non-existing organization -> Most likely a valid issue
            if (helpers.analyzeResponse(httpRequestResponse.getResponse()).getStatusCode() == 404) {
                // valid critical issue
                findingTitle = "[JS Miner] Dependency (organization not found)";
                findingDetail = "The following potentially exploitable dependency was found in a JavaScript file. The organization does not seem to be available, which indicates that it can be registered: " + url;
                severity = SEVERITY_HIGH;
            }
            // 2.2 scoped package with an existing organization -> Info issue
            else {
                // most likely not an issue but still reported as an informational
                findingTitle = "[JS Miner] Dependency (scoped package)";
                findingDetail = "The following dependency (a.k.a: scoped package) was found in a JavaScript file.";
                severity = SEVERITY_INFORMATION;
            }
        } else {
            // 3. Public NPM package
            URL url = new URL("https://registry.npmjs.org/" + npmPackage.getName());
            IHttpRequestResponse httpRequestResponse = callbacks.makeHttpRequest(Utilities.url2HttpService(url), helpers.buildHttpRequest(url));

            // 3.1 If package name does not exist -> Most likely a valid issue
            if (helpers.analyzeResponse(httpRequestResponse.getResponse()).getStatusCode() == 404) {
                // valid critical issue
                findingTitle = "[JS Miner] Dependency Confusion";
                findingDetail = "The following potentially exploitable dependency was found in a JavaScript file. There was no entry for this package on the 'npm js' registry: " + url;
                severity = SEVERITY_HIGH;
            }
            // 3.2 If package name does exist -> Info issue
            else {
                // most likely not an issue but still reported as an informational
                findingTitle = "[JS Miner] Dependency";
                findingDetail = "The following dependency was found in a JavaScript file. Most likely, this package is either publicly available or it is private.";
                severity = SEVERITY_INFORMATION;
            }
        }

        sendNewIssue(baseRequestResponse,
                findingTitle,
                findingDetail,
                npmPackage.getNameWithVersion(),
                depMatches,
                severity,
                CONFIDENCE_CERTAIN
        );
    }

    // template issue for interesting stuff
    private static void sendNewIssue(
            IHttpRequestResponse baseRequestResponse,
            String issueName,
            String description,
            String issueHighlight,
            List<int[]> responseMarkers,
            String severity,
            String confidence
    ) {
        IScanIssue newCustomIssue = new CustomScanIssue(
                baseRequestResponse.getHttpService(),
                helpers.analyzeRequest(baseRequestResponse).getUrl(),
                new IHttpRequestResponse[]{callbacks.applyMarkers(baseRequestResponse, null, responseMarkers)},
                issueName,
                SCAN_ISSUE_HEADER +
                        description +
                        HTML_LIST_OPEN +
                        HTML_LIST_BULLET_OPEN + issueHighlight + HTML_LIST_BULLET_CLOSED +
                        HTML_LIST_CLOSED +
                        "The identified matches should be highlighted in the HTTP response.<br><br>" +
                        "<br>",
                null,
                severity,
                confidence);

        Utilities.reportIssueIfNotDuplicate(newCustomIssue, baseRequestResponse);

    }

}
